# 06-é£é™©ç®¡ç†

é£é™©ç®¡ç†æ˜¯äº¤æ˜“ç³»ç»Ÿæœ€é‡è¦çš„å®‰å…¨æœºåˆ¶ã€‚æœ¬æ•™ç¨‹å°†æ·±å…¥è®²è§£å¦‚ä½•å®ç°è‡ªå®šä¹‰ RiskManagerï¼Œç¡®ä¿æ‰€æœ‰è®¢å•éƒ½ç¬¦åˆé£é™©æ§åˆ¶è¦æ±‚ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ•™ç¨‹åï¼Œä½ å°†èƒ½å¤Ÿï¼š

-   âœ… ç†è§£é£é™©ç®¡ç†çš„é‡è¦æ€§
-   âœ… å®ç°è‡ªå®šä¹‰ RiskManager
-   âœ… å®ç°å¸¸è§çš„é£é™©æ£€æŸ¥
-   âœ… å¤„ç†é£é™©æ‹’ç»å’Œæ—¥å¿—è®°å½•
-   âœ… åº”ç”¨é£é™©ç®¡ç†æœ€ä½³å®è·µ

## ğŸ›¡ï¸ é£é™©ç®¡ç†çš„é‡è¦æ€§

### ä¸ºä»€ä¹ˆéœ€è¦é£é™©ç®¡ç†ï¼Ÿ

**é£é™©ç®¡ç†ï¼ˆRisk Managementï¼‰** æ˜¯äº¤æ˜“ç³»ç»Ÿçš„"å®‰å…¨å«å£«"ï¼Œå®ƒçš„ä½œç”¨æ˜¯ï¼š

1.  **ä¿æŠ¤èµ„é‡‘**ï¼šé˜²æ­¢è¿‡åº¦é£é™©æš´éœ²
2.  **æ§åˆ¶æŸå¤±**ï¼šé™åˆ¶å•ç¬”å’Œæ€»ä½“çš„æœ€å¤§æŸå¤±
3.  **åˆè§„è¦æ±‚**ï¼šæ»¡è¶³ç›‘ç®¡å’Œå†…éƒ¨é£æ§è¦æ±‚
4.  **ç³»ç»Ÿç¨³å®š**ï¼šé˜²æ­¢å¼‚å¸¸è®¢å•å¯¼è‡´ç³»ç»Ÿå´©æºƒ

### ç±»æ¯”ç†è§£

æƒ³è±¡ RiskManager å°±åƒï¼š

-   **é“¶è¡Œé£æ§ç³»ç»Ÿ**ï¼šå®¡æŸ¥æ¯ç¬”è´·æ¬¾ç”³è¯·ï¼Œç¡®ä¿å®‰å…¨
-   **äº¤é€šä¿¡å·ç¯**ï¼šæ§åˆ¶æµé‡ï¼Œé˜²æ­¢äº‹æ•…
-   **å®‰å…¨ç½‘**ï¼šåœ¨ç­–ç•¥å‡ºé”™æ—¶æä¾›ä¿æŠ¤

### é£é™©ç®¡ç†çš„åŸåˆ™

1.  **é˜²å¾¡æ€§**ï¼šå®å¯æ‹’ç»ï¼Œä¸å¯å†’é™©
2.  **å…¨é¢æ€§**ï¼šæ£€æŸ¥æ‰€æœ‰å¯èƒ½çš„é£é™©ç‚¹
3.  **å¯è¿½æº¯**ï¼šè®°å½•æ‰€æœ‰æ‹’ç»åŸå› 
4.  **å¯é…ç½®**ï¼šæ ¹æ®éœ€æ±‚è°ƒæ•´é£é™©å‚æ•°

## ğŸ” RiskManager æ¥å£

### RiskManager Trait

æ‰€æœ‰é£é™©ç®¡ç†å™¨éƒ½å¿…é¡»å®ç° `RiskManager` traitï¼š

```rust
pub trait RiskManager<ExchangeKey, InstrumentKey> {
    type State;  // é€šå¸¸ä¸º EngineState

    fn check(
        &self,
        state: &Self::State,
        cancels: impl IntoIterator<Item = OrderRequestCancel<...>>,
        opens: impl IntoIterator<Item = OrderRequestOpen<...>>,
    ) -> (
        impl IntoIterator<Item = RiskApproved<OrderRequestCancel<...>>>,
        impl IntoIterator<Item = RiskApproved<OrderRequestOpen<...>>>,
        impl IntoIterator<Item = RiskRefused<OrderRequestCancel<...>>>,
        impl IntoIterator<Item = RiskRefused<OrderRequestOpen<...>>>,
    );
}
```

### è¿”å›å€¼è¯´æ˜

`check` æ–¹æ³•è¿”å›å››ä¸ªè¿­ä»£å™¨ï¼š

1.  **æ‰¹å‡†çš„å–æ¶ˆè®¢å•**ï¼šé€šè¿‡é£é™©æ£€æŸ¥çš„å–æ¶ˆè¯·æ±‚
2.  **æ‰¹å‡†çš„å¼€ä»“è®¢å•**ï¼šé€šè¿‡é£é™©æ£€æŸ¥çš„å¼€ä»“è¯·æ±‚
3.  **æ‹’ç»çš„å–æ¶ˆè®¢å•**ï¼šè¢«æ‹’ç»çš„å–æ¶ˆè¯·æ±‚ï¼ˆé€šå¸¸å¾ˆå°‘ï¼‰
4.  **æ‹’ç»çš„å¼€ä»“è®¢å•**ï¼šè¢«æ‹’ç»çš„å¼€ä»“è¯·æ±‚ï¼ˆåŒ…å«æ‹’ç»åŸå› ï¼‰

## ğŸ“‹ å¸¸è§é£é™©æ£€æŸ¥

### 1. è®¢å•æ•°é‡é™åˆ¶

**ç›®çš„**ï¼šé˜²æ­¢å•ç¬”è®¢å•è¿‡å¤§

**å®ç°**ï¼š

```rust
use barter::risk::check::{CheckHigherThan, RiskCheck};

// å®šä¹‰æœ€å¤§è®¢å•æ•°é‡
const MAX_ORDER_QUANTITY: CheckHigherThan<Decimal> = CheckHigherThan {
    limit: dec!(10.0),  // æœ€å¤§ 10 ä¸ª BTC
};

// åœ¨ check æ–¹æ³•ä¸­
for order in opens {
    if let Err(error) = MAX_ORDER_QUANTITY.check(&order.state.quantity) {
        refused.push(RiskRefused::new(
            order,
            format!("è®¢å•æ•°é‡ {} è¶…è¿‡æœ€å¤§é™åˆ¶ {}", order.state.quantity, MAX_ORDER_QUANTITY.limit)
        ));
        continue;
    }
    // ç»§ç»­å…¶ä»–æ£€æŸ¥...
}
```

### 2. è®¢å•é‡‘é¢é™åˆ¶

**ç›®çš„**ï¼šé™åˆ¶å•ç¬”è®¢å•çš„åä¹‰ä»·å€¼

**å®ç°**ï¼š

```rust
use barter::risk::check::util::calculate_quote_notional;

// è®¡ç®—è®¢å•åä¹‰ä»·å€¼
let notional = calculate_quote_notional(
    order.state.quantity,
    order.state.price,
    instrument_state.instrument.kind.contract_size(),
)?;

// æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§é‡‘é¢
const MAX_NOTIONAL: CheckHigherThan<Decimal> = CheckHigherThan {
    limit: dec!(1000.0),  // æœ€å¤§ 1000 USDT
};

if let Err(error) = MAX_NOTIONAL.check(&notional) {
    refused.push(RiskRefused::new(
        order,
        format!("è®¢å•é‡‘é¢ {} è¶…è¿‡æœ€å¤§é™åˆ¶ {}", notional, MAX_NOTIONAL.limit)
    ));
    continue;
}
```

### 3. æŒä»“é™åˆ¶

**ç›®çš„**ï¼šé™åˆ¶åŒæ—¶æŒæœ‰çš„äº¤æ˜“å¯¹æ•°é‡

**å®ç°**ï¼š

```rust
// æ£€æŸ¥å½“å‰æŒä»“æ•°é‡
let current_positions = state.instruments
    .iter()
    .filter(|(_, inst_state)| inst_state.position.current.is_some())
    .count();

const MAX_POSITIONS: usize = 5;

if current_positions >= MAX_POSITIONS {
    refused.push(RiskRefused::new(
        order,
        format!("å½“å‰æŒä»“æ•° {} å·²è¾¾ä¸Šé™ {}", current_positions, MAX_POSITIONS)
    ));
    continue;
}
```

### 4. èµ„é‡‘å……è¶³æ€§æ£€æŸ¥

**ç›®çš„**ï¼šç¡®ä¿æœ‰è¶³å¤Ÿçš„èµ„é‡‘æ‰§è¡Œè®¢å•

**å®ç°**ï¼š

```rust
// è·å–æŠ¥ä»·èµ„äº§ï¼ˆå¦‚ USDTï¼‰
let quote_asset = instrument_state.instrument.quote_asset();
let quote_asset_index = state.assets.asset_index(&quote_asset)?;

// è·å–å¯ç”¨ä½™é¢
let available_balance = quote_asset_index
    .balance
    .as_ref()?
    .value
    .free;

// è®¡ç®—æ‰€éœ€èµ„é‡‘
let required_funds = order.state.quantity * order.state.price;

if required_funds > available_balance {
    refused.push(RiskRefused::new(
        order,
        format!(
            "èµ„é‡‘ä¸è¶³ï¼šéœ€è¦ {}ï¼Œå¯ç”¨ {}",
            required_funds, available_balance
        )
    ));
    continue;
}
```

### 5. ä»·æ ¼åˆç†æ€§æ£€æŸ¥

**ç›®çš„**ï¼šé˜²æ­¢å¸‚ä»·å•ä»·æ ¼åç¦»å¸‚åœºå¤ªè¿œ

**å®ç°**ï¼š

```rust
use barter::risk::check::util::calculate_abs_percent_difference;

// ä»…å¯¹å¸‚ä»·å•è¿›è¡Œæ£€æŸ¥
if order.state.kind == OrderKind::Market {
    // è·å–å½“å‰å¸‚åœºä»·æ ¼
    let market_price = instrument_state.data.price()?;

    // è®¡ç®—ä»·æ ¼å·®å¼‚ç™¾åˆ†æ¯”
    let price_diff_pct = calculate_abs_percent_difference(
        order.state.price,
        market_price,
    )?;

    // æ£€æŸ¥ä»·æ ¼å·®å¼‚æ˜¯å¦è¿‡å¤§ï¼ˆä¾‹å¦‚è¶…è¿‡ 5%ï¼‰
    const MAX_PRICE_DEVIATION: CheckHigherThan<Decimal> = CheckHigherThan {
        limit: dec!(0.05),  // 5%
    };

    if let Err(error) = MAX_PRICE_DEVIATION.check(&price_diff_pct) {
        refused.push(RiskRefused::new(
            order,
            format!(
                "ä»·æ ¼åç¦»è¿‡å¤§ï¼š{}%ï¼Œæœ€å¤§å…è®¸ {}%",
                price_diff_pct * dec!(100),
                MAX_PRICE_DEVIATION.limit * dec!(100)
            )
        ));
        continue;
    }
}
```

## ğŸ’» å®ç°è‡ªå®šä¹‰ RiskManager

### å®Œæ•´ç¤ºä¾‹

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„è‡ªå®šä¹‰ RiskManager å®ç°ï¼š

```rust
use barter::{
    engine::state::{
        EngineState,
        global::DefaultGlobalData,
        instrument::data::DefaultInstrumentMarketData,
    },
    risk::{
        RiskApproved, RiskManager, RiskRefused,
        check::{
            CheckHigherThan, RiskCheck,
            util::{calculate_abs_percent_difference, calculate_quote_notional},
        },
    },
};
use barter_execution::order::{
    OrderKind,
    request::{OrderRequestCancel, OrderRequestOpen},
};
use barter_instrument::{exchange::ExchangeIndex, instrument::InstrumentIndex};
use rust_decimal::Decimal;
use rust_decimal_macros::dec;
use std::marker::PhantomData;

/// è‡ªå®šä¹‰é£é™©ç®¡ç†å™¨
#[derive(Debug, Clone)]
pub struct MyRiskManager {
    /// æœ€å¤§è®¢å•æ•°é‡
    pub max_order_quantity: CheckHigherThan<Decimal>,
    /// æœ€å¤§è®¢å•é‡‘é¢ï¼ˆUSDTï¼‰
    pub max_order_notional: CheckHigherThan<Decimal>,
    /// æœ€å¤§æŒä»“æ•°
    pub max_positions: usize,
    /// æœ€å¤§ä»·æ ¼åç¦»ç™¾åˆ†æ¯”
    pub max_price_deviation: CheckHigherThan<Decimal>,
    _phantom: PhantomData<()>,
}

impl MyRiskManager {
    pub fn new(
        max_order_quantity: Decimal,
        max_order_notional: Decimal,
        max_positions: usize,
        max_price_deviation: Decimal,
    ) -> Self {
        Self {
            max_order_quantity: CheckHigherThan { limit: max_order_quantity },
            max_order_notional: CheckHigherThan { limit: max_order_notional },
            max_positions,
            max_price_deviation: CheckHigherThan { limit: max_price_deviation },
            _phantom: PhantomData,
        }
    }
}

impl RiskManager<ExchangeIndex, InstrumentIndex>
    for MyRiskManager
{
    type State = EngineState<DefaultGlobalData, DefaultInstrumentMarketData>;

    fn check(
        &self,
        state: &Self::State,
        cancels: impl IntoIterator<Item = OrderRequestCancel<ExchangeIndex, InstrumentIndex>>,
        opens: impl IntoIterator<Item = OrderRequestOpen<ExchangeIndex, InstrumentIndex>>,
    ) -> (
        impl IntoIterator<Item = RiskApproved<OrderRequestCancel<ExchangeIndex, InstrumentIndex>>>,
        impl IntoIterator<Item = RiskApproved<OrderRequestOpen<ExchangeIndex, InstrumentIndex>>>,
        impl IntoIterator<Item = RiskRefused<OrderRequestCancel<ExchangeIndex, InstrumentIndex>>>,
        impl IntoIterator<Item = RiskRefused<OrderRequestOpen<ExchangeIndex, InstrumentIndex>>>,
    ) {
        // å–æ¶ˆè®¢å•é€šå¸¸ä¸éœ€è¦é£é™©æ£€æŸ¥ï¼Œç›´æ¥æ‰¹å‡†
        let approved_cancels: Vec<_> = cancels
            .into_iter()
            .map(RiskApproved::new)
            .collect();

        // å¤„ç†å¼€ä»“è®¢å•
        let mut approved_opens = Vec::new();
        let mut refused_opens = Vec::new();

        for order in opens {
            // è·å–äº¤æ˜“å¯¹çŠ¶æ€
            let instrument_state = state
                .instruments
                .instrument_index(&order.key.instrument);

            // æ£€æŸ¥ 1ï¼šè®¢å•æ•°é‡é™åˆ¶
            if let Err(_) = self.max_order_quantity.check(&order.state.quantity) {
                refused_opens.push(RiskRefused::new(
                    order,
                    format!(
                        "è®¢å•æ•°é‡ {} è¶…è¿‡æœ€å¤§é™åˆ¶ {}",
                        order.state.quantity,
                        self.max_order_quantity.limit
                    ),
                ));
                continue;
            }

            // æ£€æŸ¥ 2ï¼šè®¢å•é‡‘é¢é™åˆ¶
            let notional = match calculate_quote_notional(
                order.state.quantity,
                order.state.price,
                instrument_state.instrument.kind.contract_size(),
            ) {
                Ok(n) => n,
                Err(_) => {
                    refused_opens.push(RiskRefused::new(
                        order,
                        "æ— æ³•è®¡ç®—è®¢å•åä¹‰ä»·å€¼",
                    ));
                    continue;
                }
            };

            if let Err(_) = self.max_order_notional.check(&notional) {
                refused_opens.push(RiskRefused::new(
                    order,
                    format!(
                        "è®¢å•é‡‘é¢ {} è¶…è¿‡æœ€å¤§é™åˆ¶ {}",
                        notional,
                        self.max_order_notional.limit
                    ),
                ));
                continue;
            }

            // æ£€æŸ¥ 3ï¼šæŒä»“é™åˆ¶
            let current_positions = state.instruments
                .iter()
                .filter(|(_, inst_state)| inst_state.position.current.is_some())
                .count();

            if current_positions >= self.max_positions {
                refused_opens.push(RiskRefused::new(
                    order,
                    format!(
                        "å½“å‰æŒä»“æ•° {} å·²è¾¾ä¸Šé™ {}",
                        current_positions,
                        self.max_positions
                    ),
                ));
                continue;
            }

            // æ£€æŸ¥ 4ï¼šèµ„é‡‘å……è¶³æ€§
            let quote_asset = instrument_state.instrument.quote_asset();
            if let Some(quote_asset_index) = state.assets.asset_index(&quote_asset) {
                if let Some(balance) = &quote_asset_index.balance {
                    let available = balance.value.free;
                    let required = notional;

                    if required > available {
                        refused_opens.push(RiskRefused::new(
                            order,
                            format!(
                                "èµ„é‡‘ä¸è¶³ï¼šéœ€è¦ {}ï¼Œå¯ç”¨ {}",
                                required, available
                            ),
                        ));
                        continue;
                    }
                }
            }

            // æ£€æŸ¥ 5ï¼šä»·æ ¼åˆç†æ€§ï¼ˆä»…å¯¹å¸‚ä»·å•ï¼‰
            if order.state.kind == OrderKind::Market {
                if let Some(market_price) = instrument_state.data.price() {
                    if let Ok(price_diff_pct) = calculate_abs_percent_difference(
                        order.state.price,
                        market_price,
                    ) {
                        if let Err(_) = self.max_price_deviation.check(&price_diff_pct) {
                            refused_opens.push(RiskRefused::new(
                                order,
                                format!(
                                    "ä»·æ ¼åç¦»è¿‡å¤§ï¼š{}%ï¼Œæœ€å¤§å…è®¸ {}%",
                                    price_diff_pct * dec!(100),
                                    self.max_price_deviation.limit * dec!(100)
                                ),
                            ));
                            continue;
                        }
                    }
                }
            }

            // æ‰€æœ‰æ£€æŸ¥é€šè¿‡
            approved_opens.push(RiskApproved::new(order));
        }

        (
            approved_cancels,
            approved_opens,
            std::iter::empty(),
            refused_opens,
        )
    }
}
```

## ğŸ“Š é£é™©æ£€æŸ¥å·¥å…·å‡½æ•°

Barter-rs æä¾›äº†ä¸€äº›æœ‰ç”¨çš„å·¥å…·å‡½æ•°ï¼š

### calculate_quote_notional

è®¡ç®—è®¢å•çš„åä¹‰ä»·å€¼ï¼š

```rust
use barter::risk::check::util::calculate_quote_notional;

let notional = calculate_quote_notional(
    quantity,      // è®¢å•æ•°é‡
    price,         // è®¢å•ä»·æ ¼
    contract_size, // åˆçº¦å¤§å°ï¼ˆå¯¹äºç°è´§é€šå¸¸æ˜¯ 1ï¼‰
)?;
```

### calculate_abs_percent_difference

è®¡ç®—ä¸¤ä¸ªä»·æ ¼çš„ç»å¯¹ç™¾åˆ†æ¯”å·®å¼‚ï¼š

```rust
use barter::risk::check::util::calculate_abs_percent_difference;

let diff_pct = calculate_abs_percent_difference(
    price1,
    price2,
)?;
```

## ğŸ¯ å®é™…åº”ç”¨ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šç®€å•é£é™©ç®¡ç†å™¨

åªæ£€æŸ¥è®¢å•æ•°é‡ï¼š

```rust
pub struct SimpleRiskManager {
    max_quantity: Decimal,
}

impl RiskManager for SimpleRiskManager {
    fn check(&self, state: &Self::State, cancels: ..., opens: ...) -> ... {
        let approved_cancels: Vec<_> = cancels.into_iter().map(RiskApproved::new).collect();
        let mut approved_opens = Vec::new();
        let mut refused_opens = Vec::new();

        for order in opens {
            if order.state.quantity > self.max_quantity {
                refused_opens.push(RiskRefused::new(
                    order,
                    format!("æ•°é‡è¶…è¿‡é™åˆ¶: {}", self.max_quantity),
                ));
            } else {
                approved_opens.push(RiskApproved::new(order));
            }
        }

        (approved_cancels, approved_opens, std::iter::empty(), refused_opens)
    }
}
```

### ç¤ºä¾‹ 2ï¼šåŠ¨æ€é£é™©ç®¡ç†å™¨

æ ¹æ®å¸‚åœºæ³¢åŠ¨è°ƒæ•´é£é™©å‚æ•°ï¼š

```rust
pub struct DynamicRiskManager {
    base_max_notional: Decimal,
    volatility_multiplier: Decimal,
}

impl RiskManager for DynamicRiskManager {
    fn check(&self, state: &Self::State, cancels: ..., opens: ...) -> ... {
        // æ ¹æ®å¸‚åœºæ³¢åŠ¨æ€§åŠ¨æ€è°ƒæ•´æœ€å¤§è®¢å•é‡‘é¢
        // æ³¢åŠ¨æ€§é«˜æ—¶ï¼Œé™ä½æœ€å¤§è®¢å•é‡‘é¢
        let current_volatility = self.calculate_volatility(state);
        let adjusted_max = self.base_max_notional * (dec!(1.0) - current_volatility * self.volatility_multiplier);

        // ä½¿ç”¨è°ƒæ•´åçš„é™åˆ¶è¿›è¡Œæ£€æŸ¥...
    }
}
```

## ğŸ“ æ—¥å¿—è®°å½•

### è®°å½•æ‹’ç»åŸå› 

ä½¿ç”¨æ—¥å¿—è®°å½•è¢«æ‹’ç»çš„è®¢å•ï¼š

```rust
use tracing::{warn, debug};

for refused in &refused_opens {
    warn!(
        instrument = %instrument_state.instrument.name_internal,
        ?refused.item,
        reason = %refused.reason,
        "RiskManager æ‹’ç»äº†è®¢å•"
    );
}
```

### è®°å½•æ‰¹å‡†ä¿¡æ¯

è®°å½•é€šè¿‡çš„è®¢å•ï¼ˆç”¨äºå®¡è®¡ï¼‰ï¼š

```rust
use tracing::debug;

for approved in &approved_opens {
    debug!(
        instrument = %instrument_state.instrument.name_internal,
        ?approved.0,
        "RiskManager æ‰¹å‡†äº†è®¢å•"
    );
}
```

## âš ï¸ å¸¸è§é—®é¢˜

### é—®é¢˜ 1ï¼šå¦‚ä½•é€‰æ‹©åˆé€‚çš„é£é™©å‚æ•°ï¼Ÿ

**è§£ç­”**ï¼š

-   **è®¢å•æ•°é‡é™åˆ¶**ï¼šæ ¹æ®äº¤æ˜“å¯¹çš„æœ€å°/æœ€å¤§è®¢å•é‡è®¾ç½®
-   **è®¢å•é‡‘é¢é™åˆ¶**ï¼šé€šå¸¸è®¾ç½®ä¸ºæ€»èµ„é‡‘çš„ 5-10%
-   **æŒä»“é™åˆ¶**ï¼šæ ¹æ®ç­–ç•¥å’Œèµ„é‡‘è§„æ¨¡è®¾ç½®
-   **ä»·æ ¼åç¦»**ï¼šå¸‚ä»·å•é€šå¸¸è®¾ç½®ä¸º 1-5%

### é—®é¢˜ 2ï¼šé£é™©ç®¡ç†å™¨æ€§èƒ½å¦‚ä½•ä¼˜åŒ–ï¼Ÿ

**è§£ç­”**ï¼š

-   ç¼“å­˜è®¡ç®—ç»“æœ
-   æå‰é€€å‡ºï¼ˆå¦‚æœæŸä¸ªæ£€æŸ¥å¤±è´¥ï¼Œç«‹å³æ‹’ç»ï¼‰
-   é¿å…ä¸å¿…è¦çš„çŠ¶æ€æŸ¥è¯¢
-   ä½¿ç”¨ç´¢å¼•å¿«é€ŸæŸ¥æ‰¾

### é—®é¢˜ 3ï¼šå¦‚ä½•å¤„ç†é£é™©æ£€æŸ¥å¤±è´¥ï¼Ÿ

**è§£ç­”**ï¼š

1.  è®°å½•è¯¦ç»†çš„æ‹’ç»åŸå› 
2.  é€šçŸ¥ç­–ç•¥ï¼ˆå¯é€‰ï¼‰
3.  ç›‘æ§æ‹’ç»ç‡ï¼Œè°ƒæ•´ç­–ç•¥æˆ–é£é™©å‚æ•°
4.  åˆ†ææ‹’ç»åŸå› ï¼Œä¼˜åŒ–ç­–ç•¥

## âœ… æ£€æŸ¥æ¸…å•

å®Œæˆä»¥ä¸‹ä»»åŠ¡ï¼Œç¡®ä¿ä½ æŒæ¡äº†é£é™©ç®¡ç†ï¼š

-   [ ] ç†è§£é£é™©ç®¡ç†çš„é‡è¦æ€§
-   [ ] èƒ½å¤Ÿå®ç°åŸºæœ¬çš„é£é™©æ£€æŸ¥
-   [ ] çŸ¥é“å¦‚ä½•è®¡ç®—è®¢å•åä¹‰ä»·å€¼
-   [ ] èƒ½å¤Ÿæ£€æŸ¥èµ„é‡‘å……è¶³æ€§
-   [ ] èƒ½å¤Ÿé™åˆ¶æŒä»“æ•°é‡
-   [ ] çŸ¥é“å¦‚ä½•è®°å½•æ‹’ç»åŸå› 

## ğŸ¯ ä¸‹ä¸€æ­¥

ç°åœ¨ä½ å·²ç»æŒæ¡äº†é£é™©ç®¡ç†ï¼Œå¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

1.  **[07-å›æµ‹ç³»ç»Ÿ](./07-å›æµ‹ç³»ç»Ÿ.md)** - ä½¿ç”¨å†å²æ•°æ®æµ‹è¯•ç­–ç•¥æ€§èƒ½
2.  **[08-å®ç›˜äº¤æ˜“](./08-å®ç›˜äº¤æ˜“.md)** - é…ç½®å’Œéƒ¨ç½²å®ç›˜äº¤æ˜“
3.  **[10-æœ€ä½³å®è·µ](./10-æœ€ä½³å®è·µ.md)** - äº†è§£æ›´å¤šå¼€å‘å»ºè®®

## ğŸ“š å»¶ä¼¸é˜…è¯»

-   [RiskManager æ–‡æ¡£](https://docs.rs/barter/latest/barter/risk/trait.RiskManager.html)
-   [é£é™©æ£€æŸ¥å·¥å…·](https://docs.rs/barter/latest/barter/risk/check/)
-   [æœ¯è¯­è¡¨](./æœ¯è¯­è¡¨.md)

---

**é£é™©ç®¡ç†æ˜¯äº¤æ˜“ç³»ç»Ÿçš„ç”Ÿå‘½çº¿ï¼ŒåŠ¡å¿…é‡è§†ï¼** ğŸ›¡ï¸
