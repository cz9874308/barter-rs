# 04-å¸‚åœºæ•°æ®æµ

å¸‚åœºæ•°æ®æ˜¯ç®—æ³•äº¤æ˜“çš„åŸºç¡€ã€‚æœ¬æ•™ç¨‹å°†æ·±å…¥è®²è§£å¦‚ä½•ä½¿ç”¨ Barter-rs è·å–å’Œå¤„ç†å¸‚åœºæ•°æ®æµã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ•™ç¨‹åï¼Œä½ å°†èƒ½å¤Ÿï¼š

-   âœ… ç†è§£ MarketStream çš„ä½œç”¨å’ŒåŸç†
-   âœ… è®¢é˜…ä¸åŒç±»å‹çš„å¸‚åœºæ•°æ®
-   âœ… å¤„ç†å¸‚åœºäº‹ä»¶ï¼ˆMarketEventï¼‰
-   âœ… åœ¨å¤šäº¤æ˜“æ‰€åœºæ™¯ä¸‹ä½¿ç”¨å¸‚åœºæ•°æ®æµ
-   âœ… å¤„ç†è¿æ¥æ–­å¼€å’Œé‡è¿

## ğŸ“Š MarketStream æ¦‚è¿°

### ä»€ä¹ˆæ˜¯ MarketStreamï¼Ÿ

**MarketStreamï¼ˆå¸‚åœºæ•°æ®æµï¼‰** æ˜¯ Barter-rs ä¸­ç”¨äºæ¥æ”¶å®æ—¶å¸‚åœºæ•°æ®çš„æ¥å£ã€‚å®ƒé€šè¿‡ WebSocket è¿æ¥ä»äº¤æ˜“æ‰€è·å–æ•°æ®ï¼Œå¹¶å°†å…¶è½¬æ¢ä¸ºæ ‡å‡†åŒ–çš„ `MarketEvent`ã€‚

### ç±»æ¯”ç†è§£

æƒ³è±¡ MarketStream å°±åƒï¼š

-   **æ–°é—»è®¢é˜…æœåŠ¡**ï¼šä½ è®¢é˜…æ„Ÿå…´è¶£çš„äº¤æ˜“å¯¹ï¼Œç„¶åæŒç»­æ¥æ”¶æ›´æ–°
-   **å®æ—¶æ•°æ®ç®¡é“**ï¼šæ•°æ®ä»äº¤æ˜“æ‰€æµå‘ä½ çš„ç­–ç•¥
-   **æ ‡å‡†åŒ–æ¥å£**ï¼šä¸åŒäº¤æ˜“æ‰€çš„æ•°æ®è¢«ç»Ÿä¸€ä¸ºç›¸åŒæ ¼å¼

### MarketStream çš„ç‰¹ç‚¹

1.  **å®æ—¶æ€§**ï¼šä½¿ç”¨ WebSocket å®ç°ä½å»¶è¿Ÿæ•°æ®ä¼ è¾“
2.  **æ ‡å‡†åŒ–**ï¼šæ‰€æœ‰äº¤æ˜“æ‰€è¿”å›ç»Ÿä¸€çš„æ•°æ®æ ¼å¼
3.  **å¯æ‰©å±•**ï¼šæ”¯æŒæ·»åŠ æ–°çš„äº¤æ˜“æ‰€é›†æˆ
4.  **è‡ªåŠ¨é‡è¿**ï¼šè¿æ¥æ–­å¼€æ—¶è‡ªåŠ¨é‡è¿

## ğŸ“ˆ å¸‚åœºæ•°æ®ç±»å‹

Barter-rs æ”¯æŒå¤šç§ç±»å‹çš„å¸‚åœºæ•°æ®ï¼š

### 1. PublicTradesï¼ˆé€ç¬”äº¤æ˜“ï¼‰

**å®šä¹‰**ï¼šæ¯ç¬”æˆäº¤çš„è¯¦ç»†ä¿¡æ¯

**åŒ…å«ä¿¡æ¯**ï¼š

-   æˆäº¤ä»·æ ¼
-   æˆäº¤æ•°é‡
-   æˆäº¤æ—¶é—´
-   ä¹°å–æ–¹å‘

**ä½¿ç”¨åœºæ™¯**ï¼š

-   è®¡ç®—æˆäº¤é‡åŠ æƒå¹³å‡ä»·ï¼ˆVWAPï¼‰
-   åˆ†æå¸‚åœºå¾®è§‚ç»“æ„
-   æ£€æµ‹å¤§å•äº¤æ˜“

### 2. OrderBooksL1ï¼ˆä¸€çº§è®¢å•ç°¿ï¼‰

**å®šä¹‰**ï¼šæœ€ä½³ä¹°å–ä»·å’Œæ•°é‡

**åŒ…å«ä¿¡æ¯**ï¼š

-   æœ€ä½³ä¹°ä»·ï¼ˆBidï¼‰å’Œæ•°é‡
-   æœ€ä½³å–ä»·ï¼ˆAskï¼‰å’Œæ•°é‡
-   ä»·å·®ï¼ˆSpreadï¼‰

**ä½¿ç”¨åœºæ™¯**ï¼š

-   è·å–å½“å‰å¸‚åœºä»·æ ¼
-   è®¡ç®—ä¹°å–ä»·å·®
-   å¿«é€Ÿæˆäº¤ï¼ˆå¸‚ä»·å•ï¼‰

### 3. OrderBooksL2ï¼ˆäºŒçº§è®¢å•ç°¿ï¼‰

**å®šä¹‰**ï¼šæ›´æ·±çš„è®¢å•ç°¿æ·±åº¦æ•°æ®

**åŒ…å«ä¿¡æ¯**ï¼š

-   å¤šä¸ªä»·æ ¼æ¡£ä½çš„ä¹°å–è®¢å•
-   è®¢å•ç°¿æ·±åº¦

**ä½¿ç”¨åœºæ™¯**ï¼š

-   åˆ†æå¸‚åœºæ·±åº¦
-   è®¡ç®—å¤§å•å†²å‡»æˆæœ¬
-   åšå¸‚ç­–ç•¥

### 4. Candlesï¼ˆK çº¿æ•°æ®ï¼‰

**å®šä¹‰**ï¼šèšåˆçš„ K çº¿æ•°æ®

**åŒ…å«ä¿¡æ¯**ï¼š

-   å¼€ç›˜ä»·ã€æœ€é«˜ä»·ã€æœ€ä½ä»·ã€æ”¶ç›˜ä»·
-   æˆäº¤é‡
-   æ—¶é—´å‘¨æœŸ

**ä½¿ç”¨åœºæ™¯**ï¼š

-   æŠ€æœ¯åˆ†æ
-   è®¡ç®—æŠ€æœ¯æŒ‡æ ‡
-   å›æµ‹ç³»ç»Ÿ

### 5. Liquidationsï¼ˆæ¸…ç®—æ•°æ®ï¼‰

**å®šä¹‰**ï¼šå¼ºåˆ¶å¹³ä»“äº‹ä»¶

**ä½¿ç”¨åœºæ™¯**ï¼š

-   åˆ†æå¸‚åœºå‹åŠ›
-   æ£€æµ‹å¼‚å¸¸æ³¢åŠ¨

## ğŸ”Œ è®¢é˜…å¸‚åœºæ•°æ®

### åŸºæœ¬è®¢é˜…æµç¨‹

```mermaid
sequenceDiagram
    participant App as åº”ç”¨ç¨‹åº
    participant Builder as StreamBuilder
    participant Exchange as äº¤æ˜“æ‰€
    participant Stream as MarketStream

    App->>Builder: åˆ›å»º StreamBuilder
    App->>Builder: æ·»åŠ è®¢é˜…ï¼ˆSubscriptionï¼‰
    Builder->>Exchange: å»ºç«‹ WebSocket è¿æ¥
    Exchange-->>Stream: å‘é€å¸‚åœºæ•°æ®
    Stream-->>App: MarketEvent
```

### å•äº¤æ˜“æ‰€ç¤ºä¾‹

è®¢é˜…å•ä¸ªäº¤æ˜“æ‰€çš„å¸‚åœºæ•°æ®ï¼š

```rust
use barter_data::{
    exchange::binance::spot::BinanceSpot,
    streams::Streams,
    subscription::trade::PublicTrades,
};
use barter_instrument::instrument::market_data::kind::MarketDataInstrumentKind;
use futures_util::StreamExt;

#[tokio::main]
async fn main() {
    // åˆ›å»º Streams æ„å»ºå™¨
    let streams = Streams::<PublicTrades>::builder()
        // è®¢é˜… BTC/USDT çš„é€ç¬”äº¤æ˜“æ•°æ®
        .subscribe([
            (
                BinanceSpot::default(),
                "btc",
                "usdt",
                MarketDataInstrumentKind::Spot,
                PublicTrades,
            ),
        ])
        .init()
        .await
        .unwrap();

    // åˆå¹¶æ‰€æœ‰æµ
    let mut joined_stream = streams.select_all();

    // å¤„ç†å¸‚åœºäº‹ä»¶
    while let Some(event) = joined_stream.next().await {
        match event {
            Ok(market_event) => {
                println!("æ”¶åˆ°å¸‚åœºäº‹ä»¶: {:?}", market_event);
                // å¤„ç†äº‹ä»¶...
            }
            Err(error) => {
                eprintln!("é”™è¯¯: {:?}", error);
            }
        }
    }
}
```

### å¤šäº¤æ˜“æ‰€ç¤ºä¾‹

è®¢é˜…å¤šä¸ªäº¤æ˜“æ‰€çš„å¸‚åœºæ•°æ®ï¼š

```rust
use barter_data::{
    exchange::{
        binance::spot::BinanceSpot,
        coinbase::Coinbase,
        okx::Okx,
    },
    streams::Streams,
    subscription::trade::PublicTrades,
};
use barter_instrument::instrument::market_data::kind::MarketDataInstrumentKind;
use futures_util::StreamExt;

#[tokio::main]
async fn main() {
    let streams = Streams::<PublicTrades>::builder()
        // Binance è®¢é˜…
        .subscribe([
            (
                BinanceSpot::default(),
                "btc",
                "usdt",
                MarketDataInstrumentKind::Spot,
                PublicTrades,
            ),
        ])
        // Coinbase è®¢é˜…
        .subscribe([
            (
                Coinbase,
                "btc",
                "usd",
                MarketDataInstrumentKind::Spot,
                PublicTrades,
            ),
        ])
        // OKX è®¢é˜…
        .subscribe([
            (
                Okx,
                "btc",
                "usdt",
                MarketDataInstrumentKind::Spot,
                PublicTrades,
            ),
        ])
        .init()
        .await
        .unwrap();

    let mut joined_stream = streams.select_all();

    while let Some(event) = joined_stream.next().await {
        if let Ok(market_event) = event {
            println!(
                "äº¤æ˜“æ‰€: {}, äº¤æ˜“å¯¹: {:?}, ä»·æ ¼: {:?}",
                market_event.exchange,
                market_event.instrument,
                market_event.kind
            );
        }
    }
}
```

### è®¢é˜…å¤šç§æ•°æ®ç±»å‹

åŒæ—¶è®¢é˜…å¤šç§ç±»å‹çš„å¸‚åœºæ•°æ®ï¼š

```rust
use barter_data::{
    exchange::binance::spot::BinanceSpot,
    streams::builder::dynamic::indexed::init_indexed_multi_exchange_market_stream,
    subscription::SubKind,
};
use barter_instrument::index::IndexedInstruments;

#[tokio::main]
async fn main() {
    // å‡è®¾ä½ å·²ç»æœ‰äº† IndexedInstruments
    let instruments = IndexedInstruments::new(/* ... */);

    // è®¢é˜…å¤šç§æ•°æ®ç±»å‹
    let market_stream = init_indexed_multi_exchange_market_stream(
        &instruments,
        &[
            SubKind::PublicTrades,  // é€ç¬”äº¤æ˜“
            SubKind::OrderBooksL1,  // ä¸€çº§è®¢å•ç°¿
        ],
    )
    .await
    .unwrap();

    // ä½¿ç”¨ market_stream...
}
```

## ğŸ“¨ å¤„ç† MarketEvent

### MarketEvent ç»“æ„

`MarketEvent` æ˜¯æ ‡å‡†åŒ–çš„å¸‚åœºäº‹ä»¶ç»“æ„ï¼š

```rust
pub struct MarketEvent<InstrumentKey, T> {
    pub time_exchange: DateTime<Utc>,    // äº¤æ˜“æ‰€æ—¶é—´æˆ³
    pub time_received: DateTime<Utc>,    // æ¥æ”¶æ—¶é—´æˆ³
    pub exchange: ExchangeId,            // äº¤æ˜“æ‰€ ID
    pub instrument: InstrumentKey,      // äº¤æ˜“å¯¹æ ‡è¯†
    pub kind: T,                        // äº‹ä»¶ç±»å‹ï¼ˆPublicTrade, OrderBookL1 ç­‰ï¼‰
}
```

### å¤„ç†ä¸åŒç±»å‹çš„äº‹ä»¶

```rust
use barter_data::event::{MarketEvent, DataKind};

fn handle_market_event(event: MarketEvent<InstrumentIndex, DataKind>) {
    match &event.kind {
        DataKind::Trade(trade) => {
            println!(
                "é€ç¬”äº¤æ˜“: ä»·æ ¼={}, æ•°é‡={}, æ–¹å‘={:?}",
                trade.price, trade.quantity, trade.side
            );
        }
        DataKind::OrderBookL1(orderbook) => {
            println!(
                "è®¢å•ç°¿ L1: ä¹°ä»·={}, å–ä»·={}, ä»·å·®={}",
                orderbook.bid.price,
                orderbook.ask.price,
                orderbook.ask.price - orderbook.bid.price
            );
        }
        DataKind::OrderBook(orderbook) => {
            println!("è®¢å•ç°¿ L2: æ·±åº¦æ•°æ®");
        }
        DataKind::Candle(candle) => {
            println!(
                "K çº¿: O={}, H={}, L={}, C={}",
                candle.open, candle.high, candle.low, candle.close
            );
        }
        DataKind::Liquidation(liquidation) => {
            println!("æ¸…ç®—äº‹ä»¶: {:?}", liquidation);
        }
    }
}
```

### åœ¨ Strategy ä¸­ä½¿ç”¨å¸‚åœºæ•°æ®

åœ¨ç­–ç•¥ä¸­ï¼Œå¸‚åœºæ•°æ®é€šè¿‡ `EngineState` è®¿é—®ï¼š

```rust
impl AlgoStrategy for MyStrategy {
    fn generate_algo_orders(
        &self,
        state: &EngineState,
    ) -> (Vec<OrderRequestCancel>, Vec<OrderRequestOpen>) {
        let mut opens = Vec::new();

        for (instrument_index, instrument_state) in state.instruments.iter() {
            // ä» instrument_state.data è·å–å¸‚åœºæ•°æ®
            // æ³¨æ„ï¼šå…·ä½“å®ç°å–å†³äºä½ ä½¿ç”¨çš„ InstrumentData ç±»å‹

            // ç¤ºä¾‹ï¼šè·å–æœ€æ–°ä»·æ ¼ï¼ˆéœ€è¦æ ¹æ®å®é™…æ•°æ®ç»“æ„å®ç°ï¼‰
            // let latest_price = instrument_state.data.get_latest_price();

            // ä½¿ç”¨å¸‚åœºæ•°æ®ç”Ÿæˆè®¢å•...
        }

        (Vec::new(), opens)
    }
}
```

## ğŸ”„ è¿æ¥ç®¡ç†å’Œé‡è¿

### è‡ªåŠ¨é‡è¿æœºåˆ¶

MarketStream æ”¯æŒè‡ªåŠ¨é‡è¿ï¼š

```rust
use barter_data::streams::reconnect::stream::ReconnectingStream;

// MarketStream ä¼šè‡ªåŠ¨å¤„ç†é‡è¿
// å½“è¿æ¥æ–­å¼€æ—¶ï¼Œä¼šè‡ªåŠ¨å°è¯•é‡è¿
let mut stream: ReconnectingStream<...> = market_stream.into();

while let Some(event) = stream.next().await {
    match event {
        Ok(market_event) => {
            // å¤„ç†æ­£å¸¸äº‹ä»¶
        }
        Err(error) => {
            // å¤„ç†é”™è¯¯ï¼ˆå¯èƒ½æ˜¯é‡è¿è¿‡ç¨‹ä¸­çš„ä¸´æ—¶é”™è¯¯ï¼‰
            eprintln!("æµé”™è¯¯: {:?}", error);
        }
    }
}
```

### å¤„ç†è¿æ¥æ–­å¼€

åœ¨ Engine ä¸­ï¼Œè¿æ¥æ–­å¼€ä¼šè§¦å‘ `OnDisconnectStrategy`ï¼š

```rust
impl OnDisconnectStrategy for MyStrategy {
    fn on_disconnect(
        &mut self,
        engine: &mut Engine,
        exchange: ExchangeId,
    ) {
        // å¤„ç†è¿æ¥æ–­å¼€
        // ä¾‹å¦‚ï¼šå–æ¶ˆè¯¥äº¤æ˜“æ‰€çš„æ‰€æœ‰è®¢å•
        // æˆ–è€…ï¼šç­‰å¾…é‡è¿
    }
}
```

## ğŸ¯ å®é™…åº”ç”¨ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šä»·æ ¼ç›‘æ§

ç›‘æ§å¤šä¸ªäº¤æ˜“å¯¹çš„ä»·æ ¼å˜åŠ¨ï¼š

```rust
use barter_data::{
    exchange::binance::spot::BinanceSpot,
    streams::Streams,
    subscription::trade::PublicTrades,
};
use barter_instrument::instrument::market_data::kind::MarketDataInstrumentKind;
use futures_util::StreamExt;
use std::collections::HashMap;

#[tokio::main]
async fn main() {
    let streams = Streams::<PublicTrades>::builder()
        .subscribe([
            (BinanceSpot::default(), "btc", "usdt", MarketDataInstrumentKind::Spot, PublicTrades),
            (BinanceSpot::default(), "eth", "usdt", MarketDataInstrumentKind::Spot, PublicTrades),
        ])
        .init()
        .await
        .unwrap();

    let mut prices: HashMap<String, f64> = HashMap::new();
    let mut stream = streams.select_all();

    while let Some(event) = stream.next().await {
        if let Ok(market_event) = event {
            if let DataKind::Trade(trade) = &market_event.kind {
                let instrument = format!("{:?}", market_event.instrument);
                prices.insert(instrument, trade.price.to_f64().unwrap());

                println!("å½“å‰ä»·æ ¼: {:?}", prices);
            }
        }
    }
}
```

### ç¤ºä¾‹ 2ï¼šä»·å·®ç›‘æ§

ç›‘æ§ä¹°å–ä»·å·®ï¼š

```rust
use barter_data::{
    exchange::binance::spot::BinanceSpot,
    streams::Streams,
    subscription::book::OrderBooksL1,
};
use barter_instrument::instrument::market_data::kind::MarketDataInstrumentKind;
use futures_util::StreamExt;

#[tokio::main]
async fn main() {
    let streams = Streams::<OrderBooksL1>::builder()
        .subscribe([
            (BinanceSpot::default(), "btc", "usdt", MarketDataInstrumentKind::Spot, OrderBooksL1),
        ])
        .init()
        .await
        .unwrap();

    let mut stream = streams.select_all();

    while let Some(event) = stream.next().await {
        if let Ok(market_event) = event {
            if let DataKind::OrderBookL1(book) = &market_event.kind {
                let spread = book.ask.price - book.bid.price;
                let spread_percent = (spread / book.bid.price) * 100.0;

                println!(
                    "ä»·å·®: {} ({}%)",
                    spread,
                    spread_percent
                );
            }
        }
    }
}
```

## âš ï¸ å¸¸è§é—®é¢˜

### é—®é¢˜ 1ï¼šå¦‚ä½•é€‰æ‹©è®¢é˜…çš„æ•°æ®ç±»å‹ï¼Ÿ

**è§£ç­”**ï¼šæ ¹æ®ç­–ç•¥éœ€æ±‚é€‰æ‹©ï¼š

-   **éœ€è¦å®æ—¶ä»·æ ¼**ï¼šä½¿ç”¨ `PublicTrades` æˆ– `OrderBooksL1`
-   **éœ€è¦å¸‚åœºæ·±åº¦**ï¼šä½¿ç”¨ `OrderBooksL2`
-   **éœ€è¦æŠ€æœ¯åˆ†æ**ï¼šä½¿ç”¨ `Candles`
-   **éœ€è¦å¾®è§‚ç»“æ„åˆ†æ**ï¼šä½¿ç”¨ `PublicTrades`

### é—®é¢˜ 2ï¼šå¦‚ä½•å¤„ç†é«˜é¢‘æ•°æ®ï¼Ÿ

**è§£ç­”**ï¼š

-   ä½¿ç”¨å¼‚æ­¥å¤„ç†ï¼Œé¿å…é˜»å¡
-   æ‰¹é‡å¤„ç†äº‹ä»¶
-   ä½¿ç”¨ç¼“å­˜å‡å°‘é‡å¤è®¡ç®—
-   è€ƒè™‘ä½¿ç”¨ä¸“é—¨çš„æ€§èƒ½ä¼˜åŒ–åº“

### é—®é¢˜ 3ï¼šæ•°æ®å»¶è¿Ÿé—®é¢˜

**è§£ç­”**ï¼š

-   æ£€æŸ¥ç½‘ç»œè¿æ¥è´¨é‡
-   ä½¿ç”¨ç¦»äº¤æ˜“æ‰€æ›´è¿‘çš„æœåŠ¡å™¨
-   ä¼˜åŒ–æ•°æ®å¤„ç†é€»è¾‘
-   è€ƒè™‘ä½¿ç”¨ä¸“é—¨çš„ä½å»¶è¿Ÿæ–¹æ¡ˆ

## âœ… æ£€æŸ¥æ¸…å•

å®Œæˆä»¥ä¸‹ä»»åŠ¡ï¼Œç¡®ä¿ä½ æŒæ¡äº†å¸‚åœºæ•°æ®æµï¼š

-   [ ] ç†è§£ MarketStream çš„ä½œç”¨
-   [ ] èƒ½å¤Ÿè®¢é˜…å•äº¤æ˜“æ‰€æ•°æ®
-   [ ] èƒ½å¤Ÿè®¢é˜…å¤šäº¤æ˜“æ‰€æ•°æ®
-   [ ] èƒ½å¤Ÿå¤„ç†ä¸åŒç±»å‹çš„ MarketEvent
-   [ ] ç†è§£è‡ªåŠ¨é‡è¿æœºåˆ¶
-   [ ] èƒ½å¤Ÿåœ¨ Strategy ä¸­ä½¿ç”¨å¸‚åœºæ•°æ®

## ğŸ¯ ä¸‹ä¸€æ­¥

ç°åœ¨ä½ å·²ç»æŒæ¡äº†å¸‚åœºæ•°æ®æµï¼Œå¯ä»¥ç»§ç»­å­¦ä¹ ï¼š

1.  **[05-è®¢å•æ‰§è¡Œ](./05-è®¢å•æ‰§è¡Œ.md)** - ç†è§£å¦‚ä½•æ‰§è¡Œè®¢å•
2.  **[06-é£é™©ç®¡ç†](./06-é£é™©ç®¡ç†.md)** - å®ç°é£é™©æ§åˆ¶
3.  **[07-å›æµ‹ç³»ç»Ÿ](./07-å›æµ‹ç³»ç»Ÿ.md)** - ä½¿ç”¨å†å²æ•°æ®æµ‹è¯•ç­–ç•¥

## ğŸ“š å»¶ä¼¸é˜…è¯»

-   [Barter-Data æ–‡æ¡£](https://docs.rs/barter-data/latest/barter_data/)
-   [MarketEvent æ–‡æ¡£](https://docs.rs/barter-data/latest/barter_data/event/struct.MarketEvent.html)
-   [StreamBuilder æ–‡æ¡£](https://docs.rs/barter-data/latest/barter_data/streams/builder/)
-   [æœ¯è¯­è¡¨](./æœ¯è¯­è¡¨.md)

---

**ç»§ç»­å­¦ä¹ ï¼ŒæŒæ¡å®Œæ•´çš„äº¤æ˜“ç³»ç»Ÿï¼** ğŸš€
