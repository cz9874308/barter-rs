# 03-ç¬¬ä¸€ä¸ªäº¤æ˜“ç­–ç•¥

æ­å–œä½ å®Œæˆäº†æ ¸å¿ƒæ¦‚å¿µçš„å­¦ä¹ ï¼ç°åœ¨è®©æˆ‘ä»¬æ‰‹æŠŠæ‰‹ç¼–å†™ä½ çš„ç¬¬ä¸€ä¸ªäº¤æ˜“ç­–ç•¥ã€‚æœ¬æ•™ç¨‹å°†å¸¦ä½ ä»é›¶å¼€å§‹ï¼Œåˆ›å»ºä¸€ä¸ªå®Œæ•´çš„ã€å¯è¿è¡Œçš„äº¤æ˜“ç­–ç•¥ã€‚

## ğŸ¯ å­¦ä¹ ç›®æ ‡

å®Œæˆæœ¬æ•™ç¨‹åï¼Œä½ å°†èƒ½å¤Ÿï¼š

-   âœ… ç†è§£ç­–ç•¥è®¾è®¡çš„åŸºæœ¬æ€è·¯
-   âœ… å®ç°ä¸€ä¸ªç®€å•çš„ä»·æ ¼çªç ´ç­–ç•¥
-   âœ… ç¼–å†™å®Œæ•´çš„ç­–ç•¥ä»£ç 
-   âœ… æµ‹è¯•å’Œè°ƒè¯•ç­–ç•¥
-   âœ… çŸ¥é“å¦‚ä½•æ”¹è¿›ç­–ç•¥

## ğŸ’¡ ç­–ç•¥è®¾è®¡æ€è·¯

åœ¨å¼€å§‹ç¼–ç ä¹‹å‰ï¼Œè®©æˆ‘ä»¬å…ˆè®¾è®¡ç­–ç•¥çš„é€»è¾‘ã€‚

### ç­–ç•¥é€‰æ‹©ï¼šç®€å•ä»·æ ¼çªç ´ç­–ç•¥

æˆ‘ä»¬é€‰æ‹©ä¸€ä¸ªç®€å•ä½†å®Œæ•´çš„ç­–ç•¥ï¼š**ä»·æ ¼çªç ´ç­–ç•¥**

**ç­–ç•¥é€»è¾‘**ï¼š

-   **å…¥åœºè§„åˆ™**ï¼šå½“ä»·æ ¼çªç ´æœ€è¿‘ N æ ¹ K çº¿çš„æœ€é«˜ä»·æ—¶ï¼Œä¹°å…¥
-   **å‡ºåœºè§„åˆ™**ï¼šå½“ä»·æ ¼è·Œç ´æœ€è¿‘ M æ ¹ K çº¿çš„æœ€ä½ä»·æ—¶ï¼Œå–å‡º
-   **é£é™©ç®¡ç†**ï¼šæ¯æ¬¡ä¹°å…¥é‡‘é¢ä¸è¶…è¿‡æ€»èµ„é‡‘çš„ 10%

**ä¸ºä»€ä¹ˆé€‰æ‹©è¿™ä¸ªç­–ç•¥ï¼Ÿ**

-   é€»è¾‘ç®€å•ï¼Œæ˜“äºç†è§£
-   åŒ…å«å®Œæ•´çš„å…¥åœºã€å‡ºåœºã€é£é™©ç®¡ç†
-   é€‚åˆä½œä¸ºå­¦ä¹ ç¤ºä¾‹

### ç­–ç•¥ä¸‰è¦ç´ å›é¡¾

è¿˜è®°å¾—æˆ‘ä»¬åœ¨ [02-æ ¸å¿ƒæ¦‚å¿µç†è§£](./02-æ ¸å¿ƒæ¦‚å¿µç†è§£.md) ä¸­å­¦åˆ°çš„ç­–ç•¥ä¸‰è¦ç´ å—ï¼Ÿ

1.  **å…¥åœºè§„åˆ™ï¼ˆEntry Logicï¼‰**ï¼šä»€ä¹ˆæ—¶å€™ä¹°å…¥
2.  **å‡ºåœºè§„åˆ™ï¼ˆExit Logicï¼‰**ï¼šä»€ä¹ˆæ—¶å€™å–å‡º
3.  **é£é™©ç®¡ç†ï¼ˆRisk Managementï¼‰**ï¼šå¦‚ä½•æ§åˆ¶é£é™©

æˆ‘ä»¬çš„ä»·æ ¼çªç ´ç­–ç•¥å®Œæ•´åŒ…å«äº†è¿™ä¸‰ä¸ªè¦ç´ ã€‚

## ğŸ“ å®ç°æ­¥éª¤

è®©æˆ‘ä»¬åˆ†æ­¥éª¤å®ç°è¿™ä¸ªç­–ç•¥ã€‚

### æ­¥éª¤ 1ï¼šåˆ›å»ºç­–ç•¥ç»“æ„ä½“

é¦–å…ˆï¼Œæˆ‘ä»¬éœ€è¦å®šä¹‰ä¸€ä¸ªç­–ç•¥ç»“æ„ä½“æ¥å­˜å‚¨ç­–ç•¥é…ç½®ï¼š

```rust
use barter::{
    engine::state::EngineState,
    strategy::algo::AlgoStrategy,
};
use barter_execution::order::{
    id::{ClientOrderId, StrategyId},
    request::{OrderRequestCancel, OrderRequestOpen, RequestOpen},
};
use barter_instrument::{
    Side,
    exchange::ExchangeIndex,
    instrument::InstrumentIndex,
};
use rust_decimal::Decimal;
use rust_decimal_macros::dec;

/// ç®€å•ä»·æ ¼çªç ´ç­–ç•¥
#[derive(Debug, Clone)]
pub struct BreakoutStrategy {
    /// ç­–ç•¥ ID
    pub id: StrategyId,
    /// çªç ´å‘¨æœŸï¼ˆç”¨äºè®¡ç®—æœ€é«˜ä»·ï¼‰
    pub breakout_period: usize,
    /// æ­¢æŸå‘¨æœŸï¼ˆç”¨äºè®¡ç®—æœ€ä½ä»·ï¼‰
    pub stop_loss_period: usize,
    /// æ¯æ¬¡ä¹°å…¥é‡‘é¢å èµ„é‡‘çš„æ¯”ä¾‹ï¼ˆ0.1 = 10%ï¼‰
    pub position_size_ratio: Decimal,
}

impl BreakoutStrategy {
    /// åˆ›å»ºæ–°çš„ç­–ç•¥å®ä¾‹
    pub fn new(
        breakout_period: usize,
        stop_loss_period: usize,
        position_size_ratio: Decimal,
    ) -> Self {
        Self {
            id: StrategyId::new("breakout_strategy"),
            breakout_period,
            stop_loss_period,
            position_size_ratio,
        }
    }
}
```

### æ­¥éª¤ 2ï¼šå®ç° AlgoStrategy Trait

ç°åœ¨å®ç° `AlgoStrategy` traitï¼Œè¿™æ˜¯ç­–ç•¥çš„æ ¸å¿ƒï¼š

```rust
impl AlgoStrategy<ExchangeIndex, InstrumentIndex> for BreakoutStrategy {
    type State = EngineState<DefaultGlobalData, DefaultInstrumentMarketData>;

    fn generate_algo_orders(
        &self,
        state: &Self::State,
    ) -> (
        impl IntoIterator<Item = OrderRequestCancel<ExchangeIndex, InstrumentIndex>>,
        impl IntoIterator<Item = OrderRequestOpen<ExchangeIndex, InstrumentIndex>>,
    ) {
        let mut cancels = Vec::new();
        let mut opens = Vec::new();

        // éå†æ‰€æœ‰äº¤æ˜“å¯¹
        for (instrument_index, instrument_state) in state.instruments.iter() {
            // å®ç°å…¥åœºå’Œå‡ºåœºé€»è¾‘
            // ... å¾…å®ç°
        }

        (cancels, opens)
    }
}
```

### æ­¥éª¤ 3ï¼šå®ç°å…¥åœºè§„åˆ™

å…¥åœºè§„åˆ™æ˜¯ç­–ç•¥çš„æ ¸å¿ƒé€»è¾‘ã€‚è®©æˆ‘ä»¬å®ç°ä»·æ ¼çªç ´çš„å…¥åœºæ¡ä»¶ï¼š

```rust
// åœ¨ generate_algo_orders æ–¹æ³•ä¸­
for (instrument_index, instrument_state) in state.instruments.iter() {
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰æŒä»“
    let has_position = instrument_state.position.current.is_some();

    // å¦‚æœæ²¡æœ‰æŒä»“ï¼Œæ£€æŸ¥å…¥åœºæ¡ä»¶
    if !has_position {
        // è·å–æœ€æ–°ä»·æ ¼ï¼ˆè¿™é‡Œç®€åŒ–å¤„ç†ï¼Œå®é™…åº”è¯¥ä»å¸‚åœºæ•°æ®è·å–ï¼‰
        // æ³¨æ„ï¼šå®é™…å®ç°éœ€è¦ä» instrument_state.data è·å–å†å²ä»·æ ¼æ•°æ®
        // è¿™é‡Œä»…ä½œä¸ºç¤ºä¾‹è¯´æ˜é€»è¾‘

        // å…¥åœºæ¡ä»¶ï¼šä»·æ ¼çªç ´ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
        // å®é™…å®ç°éœ€è¦ï¼š
        // 1. è·å–æœ€è¿‘ N æ ¹ K çº¿çš„æœ€é«˜ä»·
        // 2. æ¯”è¾ƒå½“å‰ä»·æ ¼æ˜¯å¦çªç ´æœ€é«˜ä»·
        // 3. å¦‚æœçªç ´ï¼Œç”Ÿæˆä¹°å…¥è®¢å•

        // ç¤ºä¾‹é€»è¾‘ï¼ˆéœ€è¦æ ¹æ®å®é™…æ•°æ®ç»“æ„å®ç°ï¼‰
        if should_enter_buy(instrument_state) {
            // è®¡ç®—è®¢å•æ•°é‡ï¼ˆé£é™©ç®¡ç†ï¼‰
            if let Some(order_request) = self.create_buy_order(
                instrument_index,
                instrument_state,
                state,
            ) {
                opens.push(order_request);
            }
        }
    }
}
```

### æ­¥éª¤ 4ï¼šå®ç°å‡ºåœºè§„åˆ™

å‡ºåœºè§„åˆ™å†³å®šä½•æ—¶å¹³ä»“ï¼š

```rust
// åœ¨ generate_algo_orders æ–¹æ³•ä¸­
for (instrument_index, instrument_state) in state.instruments.iter() {
    // æ£€æŸ¥æ˜¯å¦æœ‰æŒä»“
    if let Some(position) = &instrument_state.position.current {
        // å‡ºåœºæ¡ä»¶ï¼šä»·æ ¼è·Œç ´æ­¢æŸä»·ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
        // å®é™…å®ç°éœ€è¦ï¼š
        // 1. è·å–æœ€è¿‘ M æ ¹ K çº¿çš„æœ€ä½ä»·
        // 2. æ¯”è¾ƒå½“å‰ä»·æ ¼æ˜¯å¦è·Œç ´æœ€ä½ä»·
        // 3. å¦‚æœè·Œç ´ï¼Œç”Ÿæˆå–å‡ºå¹³ä»“è®¢å•

        if should_exit_sell(instrument_state, position) {
            // ç”Ÿæˆå¹³ä»“è®¢å•
            if let Some(order_request) = self.create_sell_order(
                instrument_index,
                instrument_state,
                state,
            ) {
                opens.push(order_request);
            }
        }
    }
}
```

### æ­¥éª¤ 5ï¼šå®ç°é£é™©ç®¡ç†

é£é™©ç®¡ç†ç¡®ä¿æ¯ç¬”äº¤æ˜“çš„é£é™©å¯æ§ï¼š

```rust
impl BreakoutStrategy {
    /// åˆ›å»ºä¹°å…¥è®¢å•ï¼ŒåŒ…å«é£é™©ç®¡ç†
    fn create_buy_order(
        &self,
        instrument_index: &InstrumentIndex,
        instrument_state: &InstrumentState,
        state: &EngineState,
    ) -> Option<OrderRequestOpen<ExchangeIndex, InstrumentIndex>> {
        // 1. è·å–å¯ç”¨èµ„é‡‘
        let quote_asset = instrument_state.instrument.quote_asset();
        let quote_asset_index = state.assets.asset_index(&quote_asset)?;
        let available_balance = state.assets.asset_index(&quote_asset_index)
            .balance
            .as_ref()?
            .value
            .free;

        // 2. è®¡ç®—æœ€å¤§è®¢å•é‡‘é¢ï¼ˆä¸è¶…è¿‡æ€»èµ„é‡‘çš„æŒ‡å®šæ¯”ä¾‹ï¼‰
        let max_order_value = available_balance * self.position_size_ratio;

        // 3. è·å–å½“å‰ä»·æ ¼
        let current_price = self.get_current_price(instrument_state)?;

        // 4. è®¡ç®—è®¢å•æ•°é‡
        let quantity = max_order_value / current_price;

        // 5. åˆ›å»ºè®¢å•è¯·æ±‚
        Some(OrderRequestOpen {
            key: OrderKey {
                exchange: instrument_state.instrument.exchange.clone(),
                instrument: instrument_index.clone(),
                strategy: self.id.clone(),
                cid: ClientOrderId::random(),
            },
            state: RequestOpen {
                side: Side::Buy,
                price: current_price,
                quantity,
                kind: OrderKind::Market,  // ä½¿ç”¨å¸‚ä»·å•
                time_in_force: TimeInForce::Gtc,  // Good Till Cancel
            },
        })
    }

    /// è·å–å½“å‰ä»·æ ¼ï¼ˆç®€åŒ–ç¤ºä¾‹ï¼‰
    fn get_current_price(
        &self,
        instrument_state: &InstrumentState,
    ) -> Option<Decimal> {
        // å®é™…å®ç°éœ€è¦ä» instrument_state.data è·å–æœ€æ–°ä»·æ ¼
        // è¿™é‡Œä»…ä½œä¸ºç¤ºä¾‹
        None  // éœ€è¦æ ¹æ®å®é™…æ•°æ®ç»“æ„å®ç°
    }
}
```

## ğŸ“¦ å®Œæ•´ä»£ç ç¤ºä¾‹

ä¸‹é¢æ˜¯ä¸€ä¸ªå®Œæ•´çš„ã€å¯è¿è¡Œçš„ç­–ç•¥ç¤ºä¾‹ï¼ˆç®€åŒ–ç‰ˆï¼Œç”¨äºå­¦ä¹ ï¼‰ï¼š

```rust
use barter::{
    engine::state::{
        EngineState,
        global::DefaultGlobalData,
        instrument::data::DefaultInstrumentMarketData,
    },
    strategy::algo::AlgoStrategy,
};
use barter_execution::order::{
    id::{ClientOrderId, StrategyId},
    request::{OrderRequestCancel, OrderRequestOpen, RequestOpen},
};
use barter_instrument::{
    Side,
    exchange::ExchangeIndex,
    instrument::InstrumentIndex,
    OrderKind, TimeInForce,
};
use rust_decimal::Decimal;
use rust_decimal_macros::dec;

/// ç®€å•ä»·æ ¼çªç ´ç­–ç•¥
#[derive(Debug, Clone)]
pub struct BreakoutStrategy {
    pub id: StrategyId,
    pub breakout_period: usize,
    pub stop_loss_period: usize,
    pub position_size_ratio: Decimal,
}

impl BreakoutStrategy {
    pub fn new(
        breakout_period: usize,
        stop_loss_period: usize,
        position_size_ratio: Decimal,
    ) -> Self {
        Self {
            id: StrategyId::new("breakout_strategy"),
            breakout_period,
            stop_loss_period,
            position_size_ratio,
        }
    }
}

impl AlgoStrategy<ExchangeIndex, InstrumentIndex> for BreakoutStrategy {
    type State = EngineState<DefaultGlobalData, DefaultInstrumentMarketData>;

    fn generate_algo_orders(
        &self,
        state: &Self::State,
    ) -> (
        impl IntoIterator<Item = OrderRequestCancel<ExchangeIndex, InstrumentIndex>>,
        impl IntoIterator<Item = OrderRequestOpen<ExchangeIndex, InstrumentIndex>>,
    ) {
        let mut cancels = Vec::new();
        let mut opens = Vec::new();

        // éå†æ‰€æœ‰äº¤æ˜“å¯¹
        for (instrument_index, instrument_state) in state.instruments.iter() {
            // æ£€æŸ¥æ˜¯å¦æœ‰æŒä»“
            let has_position = instrument_state.position.current.is_some();

            if !has_position {
                // å…¥åœºé€»è¾‘ï¼šæ£€æŸ¥æ˜¯å¦åº”è¯¥ä¹°å…¥
                // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„å¸‚åœºæ•°æ®å®ç°å…·ä½“çš„çªç ´åˆ¤æ–­é€»è¾‘
                // ç¤ºä¾‹ä¸­ç®€åŒ–å¤„ç†
            } else {
                // å‡ºåœºé€»è¾‘ï¼šæ£€æŸ¥æ˜¯å¦åº”è¯¥å–å‡ºå¹³ä»“
                // æ³¨æ„ï¼šè¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„å¸‚åœºæ•°æ®å®ç°å…·ä½“çš„æ­¢æŸåˆ¤æ–­é€»è¾‘
                // ç¤ºä¾‹ä¸­ç®€åŒ–å¤„ç†
            }
        }

        (cancels, opens)
    }
}
```

**æ³¨æ„**ï¼šä¸Šé¢çš„ä»£ç æ˜¯ä¸€ä¸ªæ¡†æ¶ç¤ºä¾‹ã€‚å®é™…å®ç°éœ€è¦ï¼š

1.  ä» `instrument_state.data` è·å–å†å²ä»·æ ¼æ•°æ®
2.  è®¡ç®—æœ€é«˜ä»·å’Œæœ€ä½ä»·
3.  å®ç°å…·ä½“çš„çªç ´åˆ¤æ–­é€»è¾‘
4.  å¤„ç†è¾¹ç•Œæƒ…å†µï¼ˆæ•°æ®ä¸è¶³ã€ä»·æ ¼æ— æ•ˆç­‰ï¼‰

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### å•å…ƒæµ‹è¯•

ä¸ºç­–ç•¥ç¼–å†™å•å…ƒæµ‹è¯•ï¼š

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_breakout_strategy_creation() {
        let strategy = BreakoutStrategy::new(20, 10, dec!(0.1));
        assert_eq!(strategy.breakout_period, 20);
        assert_eq!(strategy.stop_loss_period, 10);
        assert_eq!(strategy.position_size_ratio, dec!(0.1));
    }

    // æ›´å¤šæµ‹è¯•...
}
```

### é›†æˆæµ‹è¯•

ä½¿ç”¨æ¨¡æ‹Ÿæ•°æ®æµ‹è¯•ç­–ç•¥ï¼š

```rust
#[tokio::test]
async fn test_strategy_with_mock_data() {
    // 1. åˆ›å»ºç­–ç•¥
    let strategy = BreakoutStrategy::new(20, 10, dec!(0.1));

    // 2. åˆ›å»ºæ¨¡æ‹Ÿ EngineState
    // 3. è°ƒç”¨ generate_algo_orders
    // 4. éªŒè¯ç”Ÿæˆçš„è®¢å•
}
```

## ğŸ› è°ƒè¯•æŠ€å·§

### 1. ä½¿ç”¨æ—¥å¿—

åœ¨ç­–ç•¥ä¸­æ·»åŠ æ—¥å¿—è¾“å‡ºï¼š

```rust
use tracing::{debug, info, warn};

fn generate_algo_orders(&self, state: &Self::State) -> ... {
    info!("ç­–ç•¥å¼€å§‹ç”Ÿæˆè®¢å•");

    for (instrument_index, instrument_state) in state.instruments.iter() {
        debug!(?instrument_index, "å¤„ç†äº¤æ˜“å¯¹");

        // ... ç­–ç•¥é€»è¾‘
    }
}
```

### 2. æ£€æŸ¥çŠ¶æ€

åœ¨å…³é”®ç‚¹æ£€æŸ¥çŠ¶æ€ï¼š

```rust
// æ£€æŸ¥æŒä»“çŠ¶æ€
if let Some(position) = &instrument_state.position.current {
    debug!(
        ?position,
        "å½“å‰æŒä»“ä¿¡æ¯"
    );
}

// æ£€æŸ¥å¸‚åœºæ•°æ®
debug!(
    ?instrument_state.data,
    "äº¤æ˜“å¯¹å¸‚åœºæ•°æ®"
);
```

### 3. éªŒè¯è®¢å•

åœ¨ç”Ÿæˆè®¢å•åéªŒè¯ï¼š

```rust
for order in &opens {
    debug!(
        ?order,
        "ç”Ÿæˆçš„è®¢å•è¯·æ±‚"
    );

    // éªŒè¯è®¢å•å‚æ•°
    assert!(order.state.quantity > Decimal::ZERO);
    assert!(order.state.price > Decimal::ZERO);
}
```

## ğŸ’¡ æ”¹è¿›å»ºè®®

### 1. æ·»åŠ æŠ€æœ¯æŒ‡æ ‡

-   ç§»åŠ¨å¹³å‡çº¿ï¼ˆMAï¼‰
-   ç›¸å¯¹å¼ºå¼±æŒ‡æ ‡ï¼ˆRSIï¼‰
-   å¸ƒæ—å¸¦ï¼ˆBollinger Bandsï¼‰

### 2. ä¼˜åŒ–å…¥åœº/å‡ºåœºé€»è¾‘

-   æ·»åŠ ç¡®è®¤ä¿¡å·ï¼ˆé¿å…å‡çªç ´ï¼‰
-   ä½¿ç”¨å¤šä¸ªæ—¶é—´å‘¨æœŸ
-   è€ƒè™‘æˆäº¤é‡å› ç´ 

### 3. å¢å¼ºé£é™©ç®¡ç†

-   åŠ¨æ€è°ƒæ•´ä»“ä½å¤§å°
-   æ·»åŠ æ­¢æŸå’Œæ­¢ç›ˆ
-   é™åˆ¶æœ€å¤§æŒä»“æ•°

### 4. æ€§èƒ½ä¼˜åŒ–

-   ç¼“å­˜è®¡ç®—ç»“æœ
-   å‡å°‘ä¸å¿…è¦çš„è¿­ä»£
-   ä¼˜åŒ–æ•°æ®ç»“æ„è®¿é—®

## âš ï¸ å¸¸è§é—®é¢˜

### é—®é¢˜ 1ï¼šå¦‚ä½•è·å–å†å²ä»·æ ¼æ•°æ®ï¼Ÿ

**è§£ç­”**ï¼šéœ€è¦ä» `instrument_state.data` è·å–ã€‚å…·ä½“å®ç°å–å†³äºä½ ä½¿ç”¨çš„ `InstrumentData` ç±»å‹ã€‚å¦‚æœä½¿ç”¨ `DefaultInstrumentMarketData`ï¼Œå¯èƒ½éœ€è¦æ‰©å±•å®ƒä»¥å­˜å‚¨å†å²ä»·æ ¼ã€‚

### é—®é¢˜ 2ï¼šå¦‚ä½•è®¡ç®—æŠ€æœ¯æŒ‡æ ‡ï¼Ÿ

**è§£ç­”**ï¼šå¯ä»¥ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“ï¼ˆå¦‚ `ta`ï¼‰è®¡ç®—æŠ€æœ¯æŒ‡æ ‡ï¼Œæˆ–è€…è‡ªå·±å®ç°ç®€å•çš„æŒ‡æ ‡è®¡ç®—ã€‚

### é—®é¢˜ 3ï¼šç­–ç•¥ä¸ç”Ÿæˆè®¢å•ï¼Ÿ

**è§£ç­”**ï¼šæ£€æŸ¥ä»¥ä¸‹å‡ ç‚¹ï¼š

-   äº¤æ˜“çŠ¶æ€æ˜¯å¦ä¸º `Enabled`
-   å…¥åœº/å‡ºåœºæ¡ä»¶æ˜¯å¦æ­£ç¡®
-   å¸‚åœºæ•°æ®æ˜¯å¦å¯ç”¨
-   èµ„é‡‘æ˜¯å¦å……è¶³

## âœ… æ£€æŸ¥æ¸…å•

å®Œæˆä»¥ä¸‹ä»»åŠ¡ï¼Œç¡®ä¿ä½ çš„ç­–ç•¥å®ç°æ­£ç¡®ï¼š

-   [ ] ç­–ç•¥ç»“æ„ä½“å®šä¹‰å®Œæ•´
-   [ ] å®ç°äº† `AlgoStrategy` trait
-   [ ] å…¥åœºè§„åˆ™é€»è¾‘æ­£ç¡®
-   [ ] å‡ºåœºè§„åˆ™é€»è¾‘æ­£ç¡®
-   [ ] é£é™©ç®¡ç†å®ç°æ­£ç¡®
-   [ ] ä»£ç å¯ä»¥ç¼–è¯‘é€šè¿‡
-   [ ] ç¼–å†™äº†åŸºæœ¬æµ‹è¯•
-   [ ] æ·»åŠ äº†æ—¥å¿—è¾“å‡º

## ğŸ¯ ä¸‹ä¸€æ­¥

æ­å–œï¼ä½ å·²ç»å®Œæˆäº†ç¬¬ä¸€ä¸ªäº¤æ˜“ç­–ç•¥çš„ç¼–å†™ã€‚æ¥ä¸‹æ¥å¯ä»¥ï¼š

1.  **[04-å¸‚åœºæ•°æ®æµ](./04-å¸‚åœºæ•°æ®æµ.md)** - æ·±å…¥å­¦ä¹ å¦‚ä½•è·å–å’Œå¤„ç†å¸‚åœºæ•°æ®
2.  **[05-è®¢å•æ‰§è¡Œ](./05-è®¢å•æ‰§è¡Œ.md)** - ç†è§£è®¢å•æ‰§è¡Œæµç¨‹
3.  **[06-é£é™©ç®¡ç†](./06-é£é™©ç®¡ç†.md)** - å®ç°æ›´å®Œå–„çš„é£é™©ç®¡ç†
4.  **[07-å›æµ‹ç³»ç»Ÿ](./07-å›æµ‹ç³»ç»Ÿ.md)** - ä½¿ç”¨å†å²æ•°æ®æµ‹è¯•ç­–ç•¥æ€§èƒ½

## ğŸ“š å»¶ä¼¸é˜…è¯»

-   [Strategy æ¨¡å—æ–‡æ¡£](https://docs.rs/barter/latest/barter/strategy/)
-   [AlgoStrategy Trait æ–‡æ¡£](https://docs.rs/barter/latest/barter/strategy/algo/trait.AlgoStrategy.html)
-   [EngineState æ–‡æ¡£](https://docs.rs/barter/latest/barter/engine/state/struct.EngineState.html)
-   [æœ¯è¯­è¡¨](./æœ¯è¯­è¡¨.md)

---

**ç»§ç»­å­¦ä¹ ï¼Œè®©ä½ çš„ç­–ç•¥æ›´å¼ºå¤§ï¼** ğŸš€
